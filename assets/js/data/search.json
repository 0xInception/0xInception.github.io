[ { "title": "Partially Defeating .Net Reactor's Necrobit With This Simple Trick.", "url": "/posts/defeating-reactors-necrobit/", "categories": ".NET Reactor", "tags": "C#, .NET, Reverse Engineering, .NET Reactor, Necrobit, JIT, Obfuscation, Deobfuscation", "date": "2021-08-06 06:29:20 +0000", "snippet": "I recently came across a post on tuts4you which basically said that .net reactor uses a hashtable to store pre-JIT information about methods that use Necrobit and wanted to see what it is all about for myself.The sampleWe will be using a simple .NET Framework 4.8 x86 test application on RELEASE mode with .NET Reactor v.6.7.0.0 Demo and just Necrobit with compatibility mode disabled.The goalThe goal is to dump and recompile the CIL code of certain methods.How does Necrobit work?Necrobit encrypts the method body bytes beforehand and decrypts them at runtime. It hooks the JIT compiler and replaces them in memory as soon as the method is JITed.ApproachDrag n Drop on dnSpyOpening the file on dnSpy, we see that Hello class is almost empty, with only a call on the static constructor. This is what necrobit did to it.That method has control-flow obfuscation applied to it so let‚Äôs clean it first, so it‚Äôs easier to read.Cleaning the control-flow obfuscationThere is a really handy tool for this called .NetReactorCfCleanerNote: After running it through this tool, the file doesn‚Äôt run anymore, we just want to view it.The hashtableNow if we open the method that we found previously on the static constructor and scroll down a bit, we will indeed see info added into a hashtable.If we use dnSpy‚Äôs analyzer we see that this hashtable is also used on a method which seems to be the JIT CompileMethod hookNow we have enough information, let‚Äôs break it.Retrieving the hashtableSince we are doing this dynamically and not statically, all we need to do is load the assembly and locate the field, then get its value.var assembly = Assembly.LoadFrom(\"NecrobitTest.exe\");var type = assembly.GetTypes().First(d =&gt; d.Name == \"nLvrU8AQJDKRRZAB7e\");var hashtableField = type.GetRuntimeFields().First(d =&gt; d.Name == \"Nll0SVdCxp\");var hashtableValue = (Hashtable)hashtableField.GetValue(null);We can now loop through it. The value of the entry is a struct used in the program, let‚Äôs use reflection to get the CIL byte array.foreach (DictionaryEntry entry in hashtableValue){ Console.WriteLine($\"{entry.Key} -&gt; {ExtractArray(entry.Value).Length}\");}byte[] ExtractArray(object entry){ foreach (var field in entry.GetType().GetRuntimeFields()) { if (field.FieldType == typeof(byte[])) { return (byte[])field.GetValue(entry); } } return new byte[0];}85764037 -&gt; 785729417 -&gt; 1985729460 -&gt; 10285729465 -&gt; 1285729393 -&gt; 1285729409 -&gt; 785729425 -&gt; 2285764032 -&gt; 12985763989 -&gt; 785764005 -&gt; 120 -&gt; 1Process finished with exit code 0.Key to methodWe have a key -&gt; cil byte array hashtable, now we need to find which method the key corresponds to.On the screenshot that I showed earlier I mentioned that the key is Method RVA + HInstance of the module. Let‚Äôs get the module HInstance from the assembly.var hInstance = Marshal.GetHINSTANCE(assembly.ManifestModule).ToInt64();Now if we just subtract it we get the method RVA, but it seems to be +1 so let‚Äôs subtract 1 from it.Console.WriteLine($\"{(long)entry.Key - hInstance - 1:X} -&gt; {ExtractArray(entry.Value).Length}\");20B3 -&gt; 10220B8 -&gt; 122070 -&gt; 122080 -&gt; 72090 -&gt; 22A7BF -&gt; 129A794 -&gt; 7A7A4 -&gt; 12A7C4 -&gt; 72088 -&gt; 19FFFFFFFFFD99FFFF -&gt; 1Process finished with exit code 0.Now let‚Äôs use AsmResolver to get the actual method from RVA. We load in both the PEImage and the ModuleDefinition then we get the TableStream from the DotNetDirectory and then get the MethodDefinitionRow table. We then search for the row that has our RVA and we create a MetadataToken so we can look for the MethodDefinition in the ModuleDefinitionvar peImage = PEImage.FromFile(\"NecrobitTest.exe\");var module = ModuleDefinition.FromFile(\"NecrobitTest.exe\");var table = peImage.DotNetDirectory.Metadata.GetStream&lt;TablesStream&gt;().GetTable&lt;MethodDefinitionRow&gt;().ToList();foreach (DictionaryEntry entry in hashtableValue){ var cilBytes = ExtractArray(entry.Value); var rva = (long) entry.Key - hInstance - 1; var row = table.SingleOrDefault(d =&gt; d.Body.Rva == rva); var index = table.IndexOf(row) + 1; var token = new MetadataToken(row.TableIndex, (uint)index); if (module.TryLookupMember(token, out var m)) { if (m is MethodDefinition methodDefinition) { Console.WriteLine(methodDefinition.Name); } }}.ctor.ctorget_UsernameSayHello.ctor.ctor.ctor.ctorProcess finished with exit code 0.Boom! We got the methodDefinition from the RVA!Disassembling the cil byte arrayAsmResolver has pretty handy tools for this.var operandResolver = new PhysicalCilOperandResolver(module,methodDefinition.CilMethodBody);BinaryStreamReader reader = ByteArrayDataSource.CreateReader(cilBytes);var disassembler = new CilDisassembler(in reader, operandResolver);var instructions = disassembler.ReadInstructions();foreach (var instruction in instructions){ Console.WriteLine(instruction);}.ctorIL_0000: call System.Void JOoSTcUQYrhd3hbI7F.iehh7boeaNq3xAaFC6::Hn9cnwCrR()IL_0005: ldarg.0IL_0006: call System.Void System.Object::.ctor()IL_000B: ret.ctorIL_0000: call System.Void JOoSTcUQYrhd3hbI7F.iehh7boeaNq3xAaFC6::Hn9cnwCrR()IL_0005: ldarg.0IL_0006: call System.Void System.Object::.ctor()IL_000B: retget_UsernameIL_0000: ldarg.0IL_0001: ldfld System.String NecrobitTest.Hello::&lt;Username&gt;k__BackingFieldIL_0006: retSayHelloIL_0000: ldstr \"Hello \"IL_0005: ldarg.0IL_0006: call System.String NecrobitTest.Hello::get_Username()IL_000B: call System.String System.String::Concat(System.String, System.String)IL_0010: call System.Void System.Console::WriteLine(System.String)IL_0015: ret.ctorIL_0000: ldarg.0IL_0001: call System.Void System.Attribute::.ctor()IL_0006: ret.ctorIL_0000: call System.Void JOoSTcUQYrhd3hbI7F.iehh7boeaNq3xAaFC6::Hn9cnwCrR()IL_0005: ldarg.0IL_0006: call System.Void System.Object::.ctor()IL_000B: ret.ctorIL_0000: ldarg.0IL_0001: call System.Void System.Object::.ctor()IL_0006: ret.ctorIL_0000: call System.Void JOoSTcUQYrhd3hbI7F.iehh7boeaNq3xAaFC6::Hn9cnwCrR()IL_0005: ldarg.0IL_0006: call System.Void System.Object::.ctor()IL_000B: ldarg.0IL_000C: ldarg.1IL_000D: stfld System.String NecrobitTest.Hello::&lt;Username&gt;k__BackingFieldIL_0012: retProcess finished with exit code 0.There we go, these instructions look familiar :D. Only thing left is recompiling and rebuilding it.Recompiling &amp; Rebuildingforeach (DictionaryEntry entry in hashtableValue){ var cilBytes = ExtractArray(entry.Value); var rva = (long) entry.Key - hInstance - 1; var row = table.SingleOrDefault(d =&gt; d.Body.Rva == rva); var index = table.IndexOf(row) + 1; var token = new MetadataToken(row.TableIndex, (uint) index); if (module.TryLookupMember(token, out var m)) { if (m is MethodDefinition methodDefinition) { Console.WriteLine(methodDefinition.Name); var operandResolver = new PhysicalCilOperandResolver(module,methodDefinition.CilMethodBody); BinaryStreamReader reader = ByteArrayDataSource.CreateReader(cilBytes); var disassembler = new CilDisassembler(in reader, operandResolver); var instructions = disassembler.ReadInstructions(); methodDefinition.CilMethodBody.Instructions.Clear(); methodDefinition.CilMethodBody.Instructions.AddRange(instructions); } }}module.Write(\"NecrobitTest-UnNecrobit.exe\");Final ResultGoal has been achieved üëç We could remove the junk but there‚Äôs no need in this post.LimitationsThe hashtable only contains the instruction bytes but the local variables are missing too from the method, though this was not a problem for our sample.CreditsThanks to Washi1337 for AsmResolverThanks to 0xd4d for dnSpyThanks to SychicBoy for .NetReactorCfCleanerWhere can I find the code for this?You can find the repo Here" } ]
